<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D Gomoku: Bright Studio</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background: #e0e0e0; }
        #ui {
            position: absolute; top: 20px; width: 100%;
            text-align: center; color: #333; pointer-events: none;
            text-shadow: 0 1px 2px rgba(255,255,255,0.8);
        }
        #message { font-size: 32px; font-weight: 900; margin-bottom: 5px; }
        .controls { font-size: 14px; opacity: 0.7; color: #555; }
        #restart {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            padding: 12px 30px; background: #2ecc71; border: none; border-radius: 30px;
            color: white; font-weight: bold; cursor: pointer; pointer-events: auto;
            display: none; box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
      #switch-btn {
        position: absolute;
        top: 20px;
        right: 20px;
        padding: 10px 20px;
        background: rgba(255, 255, 255, 0.8);
        border: 1px solid #ccc;
        border-radius: 5px;
        cursor: pointer;
        font-weight: bold;
        pointer-events: auto;
        z-index: 100;
    }
#switch-btn:hover { background: #fff; }
        #restart:hover { background: #27ae60; transform: translateX(-50%) scale(1.05); }
    </style>
</head>
<body>

<div id="ui">
    <div id="message">Black's Turn</div>
    <div class="controls">Left Click to Place | Right Click to Orbit | Scroll to Zoom</div>
</div>
<button id="restart" onclick="location.reload()">NEW MATCH</button>
<button id="switch-btn" onclick="window.location.href='park.html'">Switch to Park Version</button>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    const BOARD_SIZE = 15;
    const EMPTY = 0;
    const PLAYER_X = 1; 
    const PLAYER_O = 2; 
    
    let board = Array.from({length: BOARD_SIZE}, () => Array(BOARD_SIZE).fill(EMPTY));
    let currentPlayer = PLAYER_X;
    let gameOver = false;
    let winningStones = [];
    let particles = [];

    // --- Scene Setup ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf0f0f0); // Bright grey/white background
    scene.fog = new THREE.Fog(0xf0f0f0, 20, 50);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 15, 15);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // --- High-Intensity Studio Lighting ---
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.9); // High ambient light
    scene.add(ambientLight);

    const mainLight = new THREE.DirectionalLight(0xffffff, 1.2);
    mainLight.position.set(10, 20, 10);
    mainLight.castShadow = true;
    mainLight.shadow.mapSize.width = 2048;
    mainLight.shadow.mapSize.height = 2048;
    scene.add(mainLight);

    // --- Objects ---
    const boardGroup = new THREE.Group();
    scene.add(boardGroup);

    // Light Oak Wood Base
    const baseGeo = new THREE.BoxGeometry(BOARD_SIZE, 0.6, BOARD_SIZE);
    const baseMat = new THREE.MeshStandardMaterial({ color: 0xe3c193, roughness: 0.2 });
    const base = new THREE.Mesh(baseGeo, baseMat);
    base.position.y = -0.3;
    base.receiveShadow = true;
    boardGroup.add(base);

    const gridHelper = new THREE.GridHelper(BOARD_SIZE - 1, BOARD_SIZE - 1, 0x888888, 0xbbbbbb);
    gridHelper.position.y = 0.01;
    boardGroup.add(gridHelper);

    // Ghost Stone
    const ghostGeo = new THREE.SphereGeometry(0.4, 32, 32);
    ghostGeo.scale(1, 0.5, 1);
    const ghostMat = new THREE.MeshStandardMaterial({ transparent: true, opacity: 0.4 });
    const ghostStone = new THREE.Mesh(ghostGeo, ghostMat);
    ghostStone.visible = false;
    scene.add(ghostStone);

    const rayPlane = new THREE.Mesh(new THREE.PlaneGeometry(BOARD_SIZE, BOARD_SIZE), new THREE.MeshBasicMaterial({ visible: false }));
    rayPlane.rotation.x = -Math.PI / 2;
    scene.add(rayPlane);

    // --- Particle System (Confetti) ---
    function createConfetti() {
        const geometry = new THREE.PlaneGeometry(0.1, 0.1);
        for(let i=0; i<100; i++) {
            const material = new THREE.MeshBasicMaterial({
                color: new THREE.Color().setHSL(Math.random(), 0.7, 0.5),
                side: THREE.DoubleSide
            });
            const p = new THREE.Mesh(geometry, material);
            p.position.set(Math.random()-0.5, 5, Math.random()-0.5).multiplyScalar(10);
            p.velocity = new THREE.Vector3((Math.random()-0.5)*0.1, -Math.random()*0.1, (Math.random()-0.5)*0.1);
            p.rotation.set(Math.random(), Math.random(), Math.random());
            p.visible = false;
            scene.add(p);
            particles.push(p);
        }
    }
    createConfetti();

    // --- Logic ---
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    window.addEventListener('mousemove', (e) => {
        if (gameOver) return;
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const hit = raycaster.intersectObject(rayPlane)[0];
        if (hit) {
            const r = Math.round(hit.point.z + (BOARD_SIZE - 1) / 2);
            const c = Math.round(hit.point.x + (BOARD_SIZE - 1) / 2);
            if (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && board[r][c] === EMPTY) {
                ghostStone.position.set(c - (BOARD_SIZE - 1) / 2, 0.05, r - (BOARD_SIZE - 1) / 2);
                ghostStone.material.color.set(currentPlayer === PLAYER_X ? 0x000000 : 0xffffff);
                ghostStone.visible = true;
                return;
            }
        }
        ghostStone.visible = false;
    });

    window.addEventListener('mousedown', (e) => {
        if (gameOver || e.button !== 0 || !ghostStone.visible) return;
        const r = Math.round(ghostStone.position.z + (BOARD_SIZE - 1) / 2);
        const c = Math.round(ghostStone.position.x + (BOARD_SIZE - 1) / 2);
        placeStone(r, c);
    });

    function placeStone(r, c) {
        board[r][c] = currentPlayer;
        const stone = new THREE.Mesh(
            new THREE.SphereGeometry(0.42, 32, 24),
            new THREE.MeshStandardMaterial({ 
                color: currentPlayer === PLAYER_X ? 0x222222 : 0xfcfcfc,
                roughness: 0.1, metalness: 0.1 
            })
        );
        stone.scale.set(1, 0.5, 1);
        stone.castShadow = true;
        stone.position.set(c - (BOARD_SIZE - 1) / 2, 0.1, r - (BOARD_SIZE - 1) / 2);
        boardGroup.add(stone);

        const winResult = checkWin(r, c, currentPlayer);
        if (winResult) {
            triggerWin(winResult);
            return;
        }

        currentPlayer = (currentPlayer === PLAYER_X) ? PLAYER_O : PLAYER_X;
        document.getElementById('message').textContent = currentPlayer === PLAYER_X ? "Black's Turn" : "White's Turn";
    }

    function checkWin(r, c, player) {
        const directions = [[1,0], [0,1], [1,1], [1,-1]];
        for (let [dr, dc] of directions) {
            let matches = [[r,c]];
            for (let i = 1; i < 5; i++) {
                const nr = r+dr*i, nc = c+dc*i;
                if (board[nr]?.[nc] === player) matches.push([nr, nc]); else break;
            }
            for (let i = 1; i < 5; i++) {
                const nr = r-dr*i, nc = c-dc*i;
                if (board[nr]?.[nc] === player) matches.push([nr, nc]); else break;
            }
            if (matches.length >= 5) return matches;
        }
        return null;
    }

    function triggerWin(matches) {
        gameOver = true;
        ghostStone.visible = false;
        document.getElementById('restart').style.display = 'block';
        document.getElementById('message').textContent = `ðŸ† ${currentPlayer === PLAYER_X ? 'BLACK' : 'WHITE'} WINS`;
        document.getElementById('message').style.color = "#27ae60";

        boardGroup.children.forEach(obj => {
            if (obj.geometry?.type === 'SphereGeometry') {
                const r = Math.round(obj.position.z + (BOARD_SIZE - 1) / 2);
                const c = Math.round(obj.position.x + (BOARD_SIZE - 1) / 2);
                if (matches.some(m => m[0] === r && m[1] === c)) {
                    winningStones.push(obj);
                    obj.material = new THREE.MeshStandardMaterial({ color: 0xffd700, emissive: 0xffaa00, emissiveIntensity: 1 });
                }
            }
        });
        particles.forEach(p => p.visible = true);
    }

    function animate() {
        requestAnimationFrame(animate);
        controls.update();

        if (gameOver) {
            const time = Date.now() * 0.005;
            winningStones.forEach((s, i) => {
                s.position.y = 0.3 + Math.sin(time + i) * 0.2;
                s.rotation.y += 0.05;
            });
            particles.forEach(p => {
                p.position.add(p.velocity);
                p.rotation.x += 0.02;
                if(p.position.y < 0) p.position.y = 10;
            });
            boardGroup.rotation.y += 0.001;
        }

        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
</script>
</body>
</html>
